use std::collections::BTreeMap;

use derive_deref::{Deref, DerefMut};

use crate::{
    parser::{AnyDatasets, Datasets},
    structs::Config,
};

use super::Route;

#[derive(Debug, Clone, Default, Deref, DerefMut)]
pub struct Routes(BTreeMap<String, Route>);

const WEBSITE_TYPES_PATH: &str = "../website/scripts/types";

impl Routes {
    pub fn build(datasets: &Datasets, config: &Config) -> Self {
        datasets
            .to_any_dataset_vec()
            .into_iter()
            .flat_map(|dataset| dataset.to_all_map_vec())
            .fold(Self::default(), |mut routes, map| {
                routes
                    .entry(map.id(config))
                    .or_insert_with(|| Route::from(map))
                    .update(map);
                routes
            })
    }

    pub fn generate_dts_file(&self) {
        // let map_to_type = |name: &str, map: &HashMap<String, Route>| -> String {
        //     let paths = map
        //         .values()
        //         .map(|route| format!("\"{}\"", route.url_path))
        //         .join(" | ");

        //     format!("export type {}Path = {};\n", name, paths)
        // };

        // let date_type = map_to_type("Date", &self.date);

        // let height_type = map_to_type("Height", &self.height);

        // let last_type = map_to_type("Last", &self.last);

        // fs::write(
        //     format!("{WEBSITE_TYPES_PATH}/paths.d.ts"),
        //     format!("// This file is auto generated by the server\n// Manual changes are forbidden\n\n{date_type}\n{height_type}\n{last_type}"),
        // )
        // .unwrap();
    }
}
